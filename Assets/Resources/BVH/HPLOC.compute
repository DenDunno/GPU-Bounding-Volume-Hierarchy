#pragma kernel Build
#pragma enable_d3d11_debug_symbols
#include "BinaryRadixTree.hlsl"
#include "ConstructionResult.hlsl"
#include "PLOC/PLOC++.hlsl"

void Merge(const int parentId)
{
    BVHNode node = Nodes[parentId];
    BVHNode leftChild = Nodes[node.LeftChild()];
    BVHNode rightChild = Nodes[node.RightChild()];
    node.Box = leftChild.Box.Union(rightChild.Box);

    Nodes[parentId] = node;
}

int ComputeNodeIndex(uint threadId, inout bool isLeaf)
{
    uint nodeIndex = isLeaf ? ComputeLeafIndex(threadId) : threadId;
    isLeaf = false;
    return nodeIndex;
}

ConstructionResult RunHPLOC(uint id, uint globalId, uint threadId)
{
    bool isThreadActive = id < LeavesCount;
    Range range = Range::Create(id);
    bool isLeaf = true;

    while (isThreadActive && IsNotRoot(range.Size()))
    {
        id = ComputeNodeIndex(id, isLeaf);
        ParentInfo parentInfo = ChooseParent(id, range);
        isThreadActive = parentInfo.HaveBothChildrenBeenProcessed();

        if (isThreadActive)
        {
            range = parentInfo.Range;
            id = parentInfo.Id;
            PLOCMerge(range, globalId, threadId, parentInfo.Id);
        }
    }
    
    return ConstructionResult::Create(id, range.Size());
}

[numthreads(1,1,1)]
void Build(const uint globalId : SV_DispatchThreadID, const uint threadId : SV_GroupThreadID)
{
    ConstructionResult result = RunHPLOC(globalId, globalId, threadId);
    TrySetRoot(result.NodeIndex, result.RangeSize);
}