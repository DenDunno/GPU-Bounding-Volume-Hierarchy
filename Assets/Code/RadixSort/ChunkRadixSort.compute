#pragma kernel ChunkSort
#define SORTED_BITS_PER_PASS 2
#define ALL_POSSIBLE_VALUES 4 // SORTED_BITS_PER_PASS ^ 2
#define OUT_OF_BOUND_VALUE -1
#include "../BitManipulation.hlsl"
#include "../ThreadId.hlsl"
#include "../Threads.hlsl"
#include "../PrefixSum/Shaders/BlellochPrefixSum.hlsl"

RWStructuredBuffer<int> LocalPrefixSum;
RWStructuredBuffer<int> BlockSum;
RWStructuredBuffer<int> Input;
groupshared int SortedChunk[THREADS];
uniform uint OutOfBoundsElementsCount;
uniform uint ThreadGroups;
uniform uint SortLength;
uniform int BitOffset;

void MoveInputToSharedMemory(const uint threadId, const int inputValue)
{
    SortedChunk[threadId] = inputValue;
}

int GetSortedValueFromSharedMemory(const uint threadId)
{
    return SortedChunk[threadId];
}

int GetInputValue(uint globalId)
{
    return globalId >= SortLength ?
               OUT_OF_BOUND_VALUE :
               ExtractBits(Input[globalId], BitOffset, SORTED_BITS_PER_PASS);
}

int ComputeMask(const int inputValue, const int mask)
{
    return inputValue == OUT_OF_BOUND_VALUE ?
        1 :
        inputValue == mask;
}

void TryWriteToBlockSum(const ThreadId id, const int sortValue, const int totalElementsInGroup)
{
    if (id.Local == THREAD_LAST_INDEX)
    {
        const int blockSumIndex = sortValue * ThreadGroups + id.Group;
        const int isLastThreadGroup = id.Group == ThreadGroups - 1;
        const int offset = isLastThreadGroup ? OutOfBoundsElementsCount : 0;
        BlockSum[blockSumIndex] = totalElementsInGroup - offset;
    }
}

void ShuffleLocally(ThreadId id, int inputValue, int hasPassedMask, PrefixSum elementPrefixSum)
{
    const int nonMatchingElementsCount = THREADS - elementPrefixSum.TotalInGroup;
    const int indexIfTrue = nonMatchingElementsCount + elementPrefixSum.Value;
    const int indexIfFalse = id.Local - elementPrefixSum.Value;
    const int localScatterIndex = hasPassedMask ? indexIfTrue : indexIfFalse;

    SortedChunk[localScatterIndex] = inputValue;
}

void SortPerValue(const int sortValue, const ThreadId id)
{
    const int inputValue = GetSortedValueFromSharedMemory(id.Local);
    const int hasPassedMask = ComputeMask(inputValue, sortValue);
    PrefixSum elementPrefixSum = PrefixSum::ComputeExclusive(hasPassedMask, id.Local);
    TryWriteToBlockSum(id, sortValue, elementPrefixSum.TotalInGroup);
    ShuffleLocally(id, inputValue, hasPassedMask, elementPrefixSum);
    
    if (hasPassedMask)
        LocalPrefixSum[id.Global] = elementPrefixSum.Value;
}

int SortChunk(const int inputValue, const ThreadId id)
{
    MoveInputToSharedMemory(id.Local, inputValue);
    
    [unroll(ALL_POSSIBLE_VALUES)]
    for (int sortValue = 0; sortValue < ALL_POSSIBLE_VALUES; ++sortValue)
    {
        SortPerValue(sortValue, id);
    }

    return GetSortedValueFromSharedMemory(id.Local);
}

[numthreads(THREADS,1,1)]
void ChunkSort(int3 globalId : SV_DispatchThreadID, uint3 threadId : SV_GroupThreadID, int3 groupId : SV_GroupID)
{
    ThreadId id = ThreadId::Create(globalId.x, threadId.x, groupId.x);
    const int inputValue = GetInputValue(id.Global);
    Input[id.Global] = SortChunk(inputValue, id);
}