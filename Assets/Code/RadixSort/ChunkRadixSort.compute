#pragma kernel ChunkSort
#define SORTED_BITS_PER_PASS 2
#define ALL_POSSIBLE_VALUES 4 // SORTED_BITS_PER_PASS ^ 2
#define OUT_OF_BOUND_VALUE -1
#include "Assets/Code/ThreadId.hlsl"
#include "Assets/Code/BitManipulation.hlsl"
#include "Assets/Code/Threads.hlsl"
#include "../PrefixSum/Shaders/BlellochPrefixSum.hlsl"

RWStructuredBuffer<int> LocalPrefixSum; 
RWStructuredBuffer<int> Input;
uniform int ThreadGroups;
uniform uint SortLength;
uniform int BitOffset;

int GetInputValue(uint globalId)
{
    return globalId >= SortLength ?
               OUT_OF_BOUND_VALUE :
               ExtractBits(Input[globalId], BitOffset, SORTED_BITS_PER_PASS);
}

int ComputeMask(const int inputValue, const int mask)
{
    return inputValue == OUT_OF_BOUND_VALUE ?
        1 :
        inputValue == mask;
}

void TryWriteToBlockSum(const ThreadId id, const int sortValue, const int totalElementsInGroup)
{
    if (id.Local == THREAD_LAST_INDEX)
    {
        const int blockSumIndex = sortValue * ThreadGroups + id.Group;
        BlockSum[blockSumIndex] = totalElementsInGroup;
    }
}

int ComputeGlobalScatterIndex(ThreadId id, int hasPassedMask, int elementPrefixSum, int totalElementsInGroup)
{
    const int nonMatchingElementsCount = THREADS - totalElementsInGroup;
    const int indexIfTrue = nonMatchingElementsCount + elementPrefixSum;
    const int indexIfFalse = id.Local - elementPrefixSum;
    const int localScatterIndex = hasPassedMask ? indexIfTrue : indexIfFalse;
    const int globalScatterIndex = id.Group * THREADS + localScatterIndex;

    return globalScatterIndex;
}

void SortPerValue(const int inputValue, const int sortValue, const ThreadId id)
{
    const int hasPassedMask = ComputeMask(inputValue, sortValue);
    const int elementPrefixSum = ComputeExclusivePrefixSum(hasPassedMask, id.Local);
    const int totalElementsInGroup = GetGroupSum();
    
    TryWriteToBlockSum(id, sortValue, totalElementsInGroup);
    if (hasPassedMask)
    {
        LocalPrefixSum[id.Global] = elementPrefixSum;   
    }

    int scatterIndex = ComputeGlobalScatterIndex(id, hasPassedMask, elementPrefixSum, totalElementsInGroup);
    Input[scatterIndex] = inputValue;
}

void SortChunk(const int inputValue, const ThreadId id)
{
    [unroll(ALL_POSSIBLE_VALUES)]
    for (int sortValue = 0; sortValue < ALL_POSSIBLE_VALUES; ++sortValue)
    {
        const int newValue = GetInputValue(id.Global);
        SortPerValue(newValue, sortValue, id);
    }
}

[numthreads(THREADS,1,1)]
void ChunkSort(int3 globalId : SV_DispatchThreadID, uint3 threadId : SV_GroupThreadID, int3 groupId : SV_GroupID)
{
    ThreadId id = CreateThreadId(globalId.x, threadId.x, groupId.x);
    const int inputValue = GetInputValue(id.Global);
    SortChunk(inputValue, id);
}