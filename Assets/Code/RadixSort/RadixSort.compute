#pragma kernel GlobalScatter
#pragma kernel ChunkSort
#define ALL_POSSIBLE_VALUES 4 // SORTED_BITS_PER_PASS ^ 2
#define TYPE int4
#include "RadixSortBlockSum.hlsl"
#include "RadixSortInput.hlsl"
#include "../ThreadId.hlsl"
#include "../Threads.hlsl"
#include "../PrefixSum/Shaders/HillisAndSteelePrefixSum.hlsl"

RWStructuredBuffer<int> LocalPrefixSum;
RWStructuredBuffer<int> LocalShuffle;
groupshared int OffsetTable[ALL_POSSIBLE_VALUES + 1];
groupshared int LocalPrefixSumChunk[THREADS];
groupshared int SortedChunk[THREADS];

void AddToOffsetTable(int sortValue, const int totalElementsInGroup)
{
    OffsetTable[sortValue + 1] = totalElementsInGroup + OffsetTable[sortValue];
}

void TryWriteToLocalPrefixSumChunk(const uint threadId, const int hasPassedMask, const int elementPrefixSum)
{
    if (hasPassedMask)
    {
        LocalPrefixSumChunk[threadId] = elementPrefixSum;
    }
}

void InitializeOffsetTable(uint threadId)
{
    if (threadId == THREAD_LAST_INDEX)
    {
        OffsetTable[0] = 0;
    }
}

void HandleLastLocalThread(const ThreadId id, int sortValue, const int hasPassedMask,
                           const int elementExclusivePrefixSum)
{
    if (id.Local == THREAD_LAST_INDEX)
    {
        const int totalElementsInGroup = elementExclusivePrefixSum + hasPassedMask;
        WriteToBlockSum(sortValue, id.Group, totalElementsInGroup);
        AddToOffsetTable(sortValue, totalElementsInGroup);
    }
}

void BuildPrefixSumAndOffsetTable(const int inputValue, const int4 hasPassedMask, const ThreadId id)
{
    const int4 scanPerElement = ComputeExclusiveScan(hasPassedMask, id.Local);

    [unroll(ALL_POSSIBLE_VALUES)]
    for (int sortValue = 0; sortValue < ALL_POSSIBLE_VALUES; ++sortValue)
    {
        int sortValueExclusiveScan = scanPerElement[sortValue];

        if (hasPassedMask[sortValue])
        {
            LocalPrefixSumChunk[id.Local] = sortValueExclusiveScan;
        }

        if (id.Local == THREAD_LAST_INDEX)
        {
            const int4 totalElementsInGroup = scanPerElement + hasPassedMask;
            WriteToBlockSum(sortValue, id.Group, totalElementsInGroup[sortValue]);
            AddToOffsetTable(sortValue, totalElementsInGroup[sortValue]);
        }
    }

    GroupMemoryBarrierWithGroupSync();
}

void PerformLocalScatter(const RadixSortInput input, const ThreadId id)
{
    const int targetElementPrefixSum = LocalPrefixSumChunk[id.Local];
    const int totalElementsLessThanTargetElement = OffsetTable[input.ExtractedBits];
    const int localScatterIndex = totalElementsLessThanTargetElement + targetElementPrefixSum;
    GroupMemoryBarrierWithGroupSync();

    if (IsInBounds(id.Global))
    {
        LocalPrefixSumChunk[localScatterIndex] = targetElementPrefixSum;
        SortedChunk[localScatterIndex] = input.InitialValue;
    }

    GroupMemoryBarrierWithGroupSync();

    if (IsInBounds(id.Global))
    {
        LocalShuffle[id.Global] = SortedChunk[id.Local];
        LocalPrefixSum[id.Global] = LocalPrefixSumChunk[id.Local];
    }
}

[numthreads(THREADS,1,1)]
void ChunkSort(int globalId : SV_DispatchThreadID, int threadId : SV_GroupThreadID, int groupId : SV_GroupID)
{
    const ThreadId id = ThreadId::Create(globalId, threadId, groupId);
    const RadixSortInput input = RadixSortInput::Fetch(id.Global);
    InitializeOffsetTable(id.Local);
    BuildPrefixSumAndOffsetTable(input.ExtractedBits, input.HasPassedMask, id);
    PerformLocalScatter(input, id);
}

[numthreads(THREADS,1,1)]
void GlobalScatter(int globalId : SV_DispatchThreadID, int groupId : SV_GroupID)
{
    if (IsOutOfBounds(globalId)) return;

    const int inputValue = LocalShuffle[globalId];
    const int sortValue = ExtractBits(inputValue, BitOffset, SORTED_BITS_PER_PASS);

    const int blockSumPrefixSum = ReadBlockSumPrefixSum(sortValue, groupId);
    const int localPrefixSum = LocalPrefixSum[globalId];
    const int globalScatterPosition = localPrefixSum + blockSumPrefixSum;

    Input[globalScatterPosition] = inputValue;
}
