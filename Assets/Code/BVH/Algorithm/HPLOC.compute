#pragma kernel Build
#include "..//..//ThreadId.hlsl"
#include "Range.hlsl"

#define INVALID_ID -1
uint _LeavesCount;

[numthreads(256,1,1)]
void Build(const int globalId : SV_DispatchThreadID, const int threadId : SV_GroupThreadID,
           const int groupId : SV_GroupID)
{
    const uint laneSize = WaveGetLaneCount();
    const ThreadId id = ThreadId::Create(globalId, threadId, groupId);
    Range range = Range::Create(id.Global);
    bool ifLaneIsActive = id.Global < _LeavesCount;

    while (WaveActiveAnyTrue(ifLaneIsActive))
    {
        uint split = INVALID_ID;
        if (ifLaneIsActive)
        {
            int previousID = INVALID_ID;
            if (findParentID(range, _LeavesCount, params.C) == range.Right)
            {
                previousID = InterlockedExchange(params.pID, range.Right, range.Left);
                if (previousID != INVALID_ID)
                {
                    split = range.Right + 1;
                    range.Right = previousID;
                }
            }
            else
            {
                previousID = InterlockedExchange(params.pID, range.Left - 1, range.Right);
                if (previousID != INVALID_ID)
                {
                    split = range.Left;
                    range.Left = previousID;
                }
            }
            if (previousID == INVALID_ID) ifLaneIsActive = false;
        }
        
        bool final = ifLaneIsActive && range.Size() == _LeavesCount;
        uint waveMask = WaveActiveBallot(ifLaneIsActive && range.Size() > laneSize / 2 || final).x;
        while (waveMask != 0)
        {
            uint laneID = WaveActiveCountBits(waveMask);
            //plocMerge(laneID, range, split, final, params); // Wave-based PLOC++ (Algorithm 2)
            waveMask = waveMask & (waveMask - 1); // Done with current lane
        }
    }
}
